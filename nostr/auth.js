const { relayInit, getPublicKey, signEvent, getEventHash, nip19, generatePrivateKey, SimplePool } = require('nostr-tools');
const { shell } = require('electron');
(function(global){
  const LS_KEYS = { priv:'nostrcord_priv_hex', pub:'nostrcord_pub_hex', npub:'nostrcord_npub', nsec:'nostrcord_nsec', relays:'nostrcord_relays' };
  const defaultRelays = ["wss://relay.primal.net","wss://relay.damus.io","wss://nos.lol","wss://nostr.wine","wss://nostr-pub.wellorder.net"];
  const state = { relayMap:{}, priv:null, pub:null, npub:null, nsec:null, pool:null };
  function urls(){ const u = Object.keys(state.relayMap); return u.length? u : defaultRelays.slice(); }
  function saveStorage(){ if(state.priv)localStorage.setItem(LS_KEYS.priv,state.priv); if(state.pub)localStorage.setItem(LS_KEYS.pub,state.pub); if(state.npub)localStorage.setItem(LS_KEYS.npub,state.npub); if(state.nsec)localStorage.setItem(LS_KEYS.nsec,state.nsec); localStorage.setItem(LS_KEYS.relays, JSON.stringify(Object.keys(state.relayMap))); }
  function loadStorage(){ try{ const priv=localStorage.getItem(LS_KEYS.priv), pub=localStorage.getItem(LS_KEYS.pub), npub=localStorage.getItem(LS_KEYS.npub), nsec=localStorage.getItem(LS_KEYS.nsec); const rels=JSON.parse(localStorage.getItem(LS_KEYS.relays)||'[]'); if(priv&&pub&&npub&&nsec){ state.priv=priv; state.pub=pub; state.npub=npub; state.nsec=nsec; } (rels.length? rels : defaultRelays).forEach(u=> state.relayMap[u.replace(/\/$/,'')] = null); state.relayMap["wss://relay.primal.net"] = state.relayMap["wss://relay.primal.net"] ?? null; }catch(e){ console.warn('storage load error', e); } }
  function connectAll(){ if(!state.pool) state.pool=new SimplePool(); urls().forEach(u=>{ const url=u.replace(/\/$/,''); if(state.relayMap[url]) return; try{ const r = relayInit(url); r.on('connect',()=>console.log('✅ relay connected',url)); r.on('error',()=>console.warn('⚠️ relay error',url)); r.connect(); state.relayMap[url]=r; }catch(e){ console.warn('relay init failed', url, e); } }); }
  function setRelays(u){ Object.values(state.relayMap).forEach(r=>{try{r.close();}catch{}}); state.relayMap={}; u.forEach(x=>state.relayMap[x.replace(/\/$/,'')]=null); connectAll(); saveStorage(); }
  function addRelay(u){ const x=u.replace(/\/$/,''); state.relayMap[x]=null; connectAll(); saveStorage(); }
  function removeRelay(u){ const x=u.replace(/\/$/,''); try{state.relayMap[x]?.close();}catch{} delete state.relayMap[x]; saveStorage(); }
  function toggleRelay(u){ const x=u.replace(/\/$/,''); if(state.relayMap[x]){ try{state.relayMap[x].close();}catch{} delete state.relayMap[x]; } else { state.relayMap[x]=null; connectAll(); } saveStorage(); }
  function _derive(pub,priv){ state.priv=priv; state.pub=pub; state.npub=nip19.npubEncode(pub); state.nsec=nip19.nsecEncode(priv); saveStorage(); connectAll(); }
  function loginWithNsec(n){ if(!n) throw new Error('No key provided'); let priv; if(String(n).startsWith('nsec1')){ const dec=nip19.decode(n); priv=dec.data; } else { priv=n; } const pub=getPublicKey(priv); _derive(pub,priv); return { npub:state.npub, nsec:state.nsec }; }
  function generateKeys(){ const priv=generatePrivateKey(); const pub=getPublicKey(priv); _derive(pub,priv); return { npub:state.npub, nsec:state.nsec }; }
  async function publishAll(evt){ if(!state.pool) state.pool=new SimplePool(); const ps = urls().map(u=> new Promise(async (resolve)=>{ try{ await state.pool.publish([u], evt); resolve({url:u, ok:true}); } catch(e){ resolve({url:u, ok:false, error:String(e)}); } })); return await Promise.allSettled(ps); }
  async function publishNote(text){ if(!state.priv) throw new Error('Not logged in'); const evt={kind:1, content:text, created_at:Math.floor(Date.now()/1000), tags:[]}; evt.pubkey=state.pub; evt.id=getEventHash(evt); evt.sig=signEvent(evt,state.priv); return await publishAll(evt); }
  async function publishLike(target){ if(!state.priv) throw new Error('Not logged in'); const evt={kind:7, content:"+", created_at:Math.floor(Date.now()/1000), tags:[['e',target.id],['p',target.pubkey]]}; evt.pubkey=state.pub; evt.id=getEventHash(evt); evt.sig=signEvent(evt,state.priv); return await publishAll(evt); }
  async function publishRepost(target){ if(!state.priv) throw new Error('Not logged in'); const evt={kind:6, content:JSON.stringify(target), created_at:Math.floor(Date.now()/1000), tags:[['e',target.id],['p',target.pubkey]]}; evt.pubkey=state.pub; evt.id=getEventHash(evt); evt.sig=signEvent(evt,state.priv); return await publishAll(evt); }
  async function publishReply(parent,text){ if(!state.priv) throw new Error('Not logged in'); const evt={kind:1, content:text, created_at:Math.floor(Date.now()/1000), tags:[['e',parent.id],['p',parent.pubkey]]}; evt.pubkey=state.pub; evt.id=getEventHash(evt); evt.sig=signEvent(evt,state.priv); return await publishAll(evt); }
  function openZap(lud16,amountSats=21){ if(!lud16){ alert('No lightning address set.'); return; } const ln=`lightning:${lud16}`; try{ shell.openExternal(ln); }catch(e){ shell.openExternal(`https://getalby.com/p/${encodeURIComponent(lud16)}?amount=${amountSats*1000}`); } }
  function sub(filters, onEvent, onEose){ if(!state.pool) state.pool=new SimplePool(); const s=state.pool.sub(urls(), filters); s.on('event', onEvent); if(onEose) s.on('eose', onEose); return s; }
  function logout(){ try{ state.pool?.close(urls()); }catch{} Object.values(state.relayMap).forEach(r=>{try{r.close();}catch{}}); localStorage.removeItem(LS_KEYS.priv); localStorage.removeItem(LS_KEYS.pub); localStorage.removeItem(LS_KEYS.npub); localStorage.removeItem(LS_KEYS.nsec); localStorage.removeItem(LS_KEYS.relays); state.relayMap={}; state.priv=state.pub=state.npub=state.nsec=null; state.pool=null; }
  function initOnLoad(){ loadStorage(); connectAll(); }
  global.NostrAuth = { state, initOnLoad, loginWithNsec, generateKeys, logout, publishNote, publishLike, publishRepost, publishReply, openZap, setRelays, addRelay, removeRelay, toggleRelay, sub };
})(window);
